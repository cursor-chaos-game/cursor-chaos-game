<script>
    // B√ñL√úM A: G√úVENLƒ∞K VE AYARLAR
    // KULLANICI ƒ∞STEƒûƒ∞ √úZERƒ∞NE G√úVENLƒ∞K KODU TAMAMEN KALDIRILMI≈ûTIR!
    
    // KORUMA KATMANI: KONSOL DENETƒ∞Mƒ∞ (Hƒ∞LE ENGELLEME)
    (function() {
        const check = () => {
            if (window.outerWidth - window.innerWidth > 100 || window.outerHeight - window.innerHeight > 100) {
                if (gameState === 'playing') {
                    pauseGame();
                    alert("Hile giri≈üimi algƒ±landƒ±! Oyun durduruldu. L√ºtfen konsolu kapatƒ±n.");
                }
            }
        };
        window.addEventListener('resize', check);
        setInterval(check, 1000);
    })();


    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // √á√∂z√ºn√ºrl√ºk deƒüi≈ütiƒüinde tuval boyutunu ayarla
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // Oyuncu konumunu ortada tutmaya √ßalƒ±≈ü
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.targetX = player.x;
        player.targetY = player.y;
    });

    // Oyun Durumu
    let gameState = 'menu'; // menu, playing, paused, gameover, countdown
    let gameRunning = false;
    
    // B√ñL√úM B: DEƒûƒ∞≈ûKENLER VE G√úVENLƒ∞ DEPOLAMA
    
    // G√ºvenli depolama (Basitle≈ütirilmi≈ü hali)
    const DOMAIN_KEY = "ImlecChaosKey"; // Yine de karƒ±≈ütƒ±rma anahtarƒ± kalsƒ±n
    
    function getSafe(key, defaultValue) {
            const val = localStorage.getItem(key + DOMAIN_KEY);
            if (!val) return defaultValue;
            try {
                // Basit Karƒ±≈ütƒ±rma (XOR)
                const decoded = val.split('').map((char, i) => String.fromCharCode(char.charCodeAt(0) ^ (DOMAIN_KEY.charCodeAt(i % DOMAIN_KEY.length)))).join('');
                return JSON.parse(decoded);
            } catch (e) {
                return defaultValue;
            }
    }

    function setSafe(key, value) {
        try {
            const encoded = JSON.stringify(value).split('').map((char, i) => String.fromCharCode(char.charCodeAt(0) ^ (DOMAIN_KEY.charCodeAt(i % DOMAIN_KEY.length)))).join('');
            localStorage.setItem(key + DOMAIN_KEY, encoded);
        } catch (e) {
            // Hata durumunda bile oyuna devam et
        }
    }

    // Temel ƒ∞statistikler
    let score = 0;
    let health = 3;
    let wave = 1;
    let gameCrystals = 0; // Oyun i√ßinde toplanan
    let lastUpdateTime = performance.now(); // Zaman b√ºt√ºnl√ºƒü√º kontrol√º

    // Kalƒ±cƒ± ƒ∞statistikler
    let crystals = getSafe('crystals', 0);
    let totalCrystalsEarned = getSafe('totalCrystals', 0);
    let highestWave = getSafe('highestWave', 1);

    // üîß D√úZELTME: totalPlayTime her zaman sayƒ± olsun
    let totalPlayTime = Number(getSafe('totalPlayTime', 0)) || 0;

    let currentSkin = getSafe('currentSkin', 'default');
    
    // Ses Durumu
    let isAudioOn = getSafe('isAudioOn', true);
    const bgMusic = document.getElementById('bgMusic');
    if (bgMusic) {
        bgMusic.volume = 0.4;
    }

    // Satƒ±n alƒ±nan g√º√ßlendirmeler
    const BOOSTS = {
        startShield: { cost: 500, purchased: getSafe('startShield', false) },
        extraLife: { cost: 750, purchased: getSafe('extraLife', false) },
        speedBoost: { cost: 1000, purchased: getSafe('speedBoost', false) },
        magnetBoost: { cost: 1200, purchased: getSafe('magnetBoost', false) }
    };

    // Kozmetikler
    const SKINS = {
        'default': { cost: 0, purchased: true, draw: drawPlayerDefault },
        'star': { cost: 2000, purchased: getSafe('skin-star', false), draw: drawPlayerStar },
        'square': { cost: 1500, purchased: getSafe('skin-square', false), draw: drawPlayerSquare },
        'triangle': { cost: 2500, purchased: getSafe('skin-triangle', false), draw: drawPlayerTriangle },
        'ring': { cost: 3000, purchased: getSafe('skin-ring', false), draw: drawPlayerRing }
    };

    // Oyun ƒ∞√ßi Durumlar
    let hasShield = false;
    let playerSpeedMultiplier = 1;
    let activeBoosts = [];

    // Oyuncu
    let player = {
        x: 0,
        y: 0,
        radius: 20,
        color: '#4ecdc4',
        baseSpeed: 6,
        targetX: 0,
        targetY: 0,
        invincible: 0 // G√∂r√ºnmezlik s√ºresi (frame)
    };

    // Varlƒ±klar
    let enemies = [];
    let stars = [];
    let powerups = [];
    let crystalDrops = [];
    let particles = [];
    
    // Dalga Y√∂neticisi
    const WAVE_MANAGER = {
        getEnemyCount: (w) => 2 + Math.floor(w / 2) + Math.min(w, 10),
        getStarCount: (w) => 3 + Math.floor(w / 3),
        // Dƒ∞NAMƒ∞K ZORLUK: Her dalgada %8 hƒ±z artƒ±≈üƒ±
        getEnemySpeedMultiplier: (w) => 1 + (w * 0.08), 
        isBossWave: (w) => w % 5 === 0,
        getBossHealth: (w) => 10 + (w * 5)
    };
    let countdownValue = 0; // Geri sayƒ±m i√ßin yeni deƒüi≈üken

    // Klavye ve Dokunmatik Kontroller
    const keys = {};
    document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    let touchStartX = 0;
    let touchStartY = 0;
    let isTouching = false; // Mouse basƒ±lƒ±/Parmak ekranda mƒ±?

    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('mousedown', handleMouseDown, { passive: false });
    canvas.addEventListener('mousemove', handleMouseMove, { passive: false });
    canvas.addEventListener('mouseup', handleMouseUp, { passive: false });

    // Mouse Kontrolleri
    function handleMouseDown(e) {
        if (gameState !== 'playing') return;
        player.targetX = e.clientX;
        player.targetY = e.clientY;
        isTouching = true; 
    }

    function handleMouseMove(e) {
        if (gameState !== 'playing') return;
        player.targetX = e.clientX;
        player.targetY = e.clientY;
    }

    function handleMouseUp(e) {
        if (gameState !== 'playing') return;
        // isTouching'i burada sƒ±fƒ±rlamƒ±yoruz, hedef takibi mouse move ile devam ediyor
    }


    // Dokunmatik Kontroller
    function handleTouchStart(e) {
        if (gameState !== 'playing') return;
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        
        player.targetX = touch.clientX;
        player.targetY = touch.clientY;
        isTouching = true;
    }

    function handleTouchMove(e) {
        if (gameState !== 'playing') return;
        e.preventDefault();
        const touch = e.touches[0];
        
        player.targetX = touch.clientX;
        player.targetY = touch.clientY;
    }

    function handleTouchEnd(e) {
        if (gameState !== 'playing') return;
        e.preventDefault();
        isTouching = false; 
    }

    // B√ñL√úM C: UI VE MAƒûAZA ƒ∞≈ûLEMLERƒ∞

    // üîß D√úZELTME: toggleAudio ba≈ülangƒ±√ßta durumu TERS √ßevirmesin, sadece kullanƒ±cƒ± tƒ±klayƒ±nca √ßalƒ±≈üsƒ±n.
    function applyAudioState() {
        if (bgMusic) {
            bgMusic.muted = !isAudioOn;
            if (isAudioOn && gameState === 'menu' && bgMusic.paused) {
                bgMusic.play().catch(e => {});
            }
        }
        const btn = document.getElementById('audioToggle');
        if (btn) btn.textContent = isAudioOn ? 'üîä' : 'üîá';
    }

    function toggleAudio() {
        isAudioOn = !isAudioOn;
        setSafe('isAudioOn', isAudioOn);
        applyAudioState();
    }

    document.addEventListener('DOMContentLoaded', () => {
        // üîß ESKƒ∞ HATA: toggleAudio() √ßaƒüƒ±rƒ±yordun, her yenilemede tercihi tersine √ßeviriyordu.
        applyAudioState(); 
        updateMainMenuUI();
        updateShopUI();
        
        document.body.addEventListener('click', () => {
            if (bgMusic && isAudioOn && bgMusic.paused) {
                bgMusic.play().catch(e => {});
            }
        }, { once: true });
    });
    
    function updateMainMenuUI() {
        document.getElementById('mainMenuCrystals').textContent = crystals;
        document.getElementById('highestWave').textContent = highestWave;
        document.getElementById('totalCrystals').textContent = totalCrystalsEarned;
        document.getElementById('totalPlayTime').textContent = totalPlayTime.toFixed(0);
    }

    function switchShopTab(tab) {
        document.getElementById('boostsContent').style.display = 'none';
        document.getElementById('cosmeticsContent').style.display = 'none';
        document.getElementById('boostsTab').classList.remove('active');
        document.getElementById('cosmeticsTab').classList.remove('active');
        
        document.getElementById(tab + 'Content').style.display = 'flex';
        document.getElementById(tab + 'Tab').classList.add('active');
        updateShopUI();
    }

    function openShop(initialTab = 'boosts') {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('shopScreen').style.display = 'flex';
        switchShopTab(initialTab);
    }

    function closeShop() {
        document.getElementById('shopScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'flex';
        updateMainMenuUI();
    }

    function buyItem(itemType, cost) {
        if (BOOSTS[itemType].purchased) {
            alert('Bu g√º√ßlendirme zaten kalƒ±cƒ± olarak satƒ±n alƒ±nmƒ±≈ü. ‚úÖ');
            return;
        }
        if (crystals < cost) {
            alert('Yetersiz kristal! üíé');
            return;
        }

        crystals -= cost;
        setSafe('crystals', crystals);
        BOOSTS[itemType].purchased = true;
        setSafe(itemType, true);
        
        alert('‚úÖ Kalƒ±cƒ± olarak satƒ±n alƒ±ndƒ±! Oyuna ba≈üladƒ±ƒüƒ±nƒ±zda otomatik aktif olacak.');
        updateShopUI();
    }
    
    function buySkin(skinType, cost) {
        if (SKINS[skinType].purchased) {
            equipSkin(skinType);
            return;
        }
        if (crystals < cost) {
            alert('Yetersiz kristal! üíé');
            return;
        }
        
        crystals -= cost;
        setSafe('crystals', crystals);
        SKINS[skinType].purchased = true;
        setSafe('skin-' + skinType, true);
        
        alert('üéâ Yeni imle√ß satƒ±n alƒ±ndƒ±! ≈ûimdi donatƒ±lƒ±yor.');
        equipSkin(skinType);
        updateShopUI();
    }
    
    function equipSkin(skinType) {
        currentSkin = skinType;
        setSafe('currentSkin', currentSkin);
        updateShopUI();
    }

    function updateShopUI() {
        document.getElementById('shopCrystals').textContent = crystals;
        
        for (const key in BOOSTS) {
            const itemDiv = document.getElementById('item-' + key);
            if (!itemDiv) continue;
            if (BOOSTS[key].purchased) {
                itemDiv.classList.add('purchased');
                itemDiv.querySelector('button').textContent = 'SATIN ALINDI';
                itemDiv.querySelector('button').disabled = true;
            }
        }
        
        for (const key in SKINS) {
            const skinDiv = document.getElementById('skin-' + key);
            if (!skinDiv) continue;

            skinDiv.classList.remove('purchased', 'equipped');
            const button = skinDiv.querySelector('button');

            if (SKINS[key].purchased) {
                skinDiv.classList.add('purchased');
                if (key === currentSkin) {
                    skinDiv.classList.add('equipped');
                    button.textContent = 'DONATILDI';
                    button.disabled = true;
                } else {
                    button.textContent = 'DONAT';
                    button.disabled = false;
                    button.onclick = () => equipSkin(key);
                }
            } else {
                button.textContent = 'SATIN AL';
                button.disabled = false;
                button.onclick = () => buySkin(key, SKINS[key].cost);
            }
        }
    }

    function updateGameUI() {
        document.getElementById('score').textContent = score;
        document.getElementById('wave').textContent = wave;
        document.getElementById('gameCrystals').textContent = gameCrystals;
        
        let healthDisplay = '';
        for (let i = 0; i < health; i++) healthDisplay += '‚ù§Ô∏è';
        document.getElementById('health').textContent = healthDisplay || 'üíÄ';
        
        document.getElementById('shieldIndicator').style.display = hasShield ? 'block' : 'none';
        
        if (activeBoosts.length > 0) {
            document.getElementById('activeBoosts').style.display = 'flex';
            document.getElementById('activeBoosts').innerHTML = activeBoosts.map(b => b.icon + ' ' + b.name).join(' | ');
        } else {
            document.getElementById('activeBoosts').style.display = 'none';
        }
    }

    // Reklam sim√ºlasyonu
    let adCallback = null;

    function watchAd(type) {
        adCallback = type;
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('shopScreen').style.display = 'none';
        document.getElementById('adScreen').style.display = 'flex';
        
        let countdown = 5;
        document.getElementById('adTimer').textContent = countdown;
        
        const adInterval = setInterval(() => {
            countdown--;
            document.getElementById('adTimer').textContent = countdown;
            
            if (countdown <= 0) {
                clearInterval(adInterval);
                finishAd();
            }
        }, 1000);
    }

    function finishAd() {
        document.getElementById('adScreen').style.display = 'none';
        
        if (adCallback === 'revive') {
            health = 2 + (BOOSTS.extraLife.purchased ? 1 : 0); 
            hasShield = true;
            updateGameUI();
            document.getElementById('reviveOffer').style.display = 'none';
            resumeGame();
        } else if (adCallback === 'crystals') {
            const reward = 50;
            crystals += reward;
            totalCrystalsEarned += reward;
            setSafe('crystals', crystals);
            setSafe('totalCrystals', totalCrystalsEarned);
            alert(`üéÅ ${reward} Kristal kazandƒ±nƒ±z!`);
            document.getElementById('shopScreen').style.display = 'flex';
            updateShopUI();
        }
        
        adCallback = null;
    }
    
    // **YENƒ∞ √ñZELLƒ∞K:** OYUN BA≈ûLATMA VE GERƒ∞ SAYIM
    function prepareGame() {
        // UI gizleme/g√∂sterme
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('waveIndicator').style.display = 'block';
        document.getElementById('pauseBtn').style.display = 'flex';
        document.getElementById('countdownDisplay').style.display = 'block';
        
        // Ba≈ülangƒ±√ß deƒüerlerini ayarla (startGame √∂ncesi hazƒ±rlƒ±k)
        gameState = 'countdown';
        gameRunning = false;
        countdownValue = 3;
        document.getElementById('countdownDisplay').textContent = countdownValue;
        
        // T√ºm oyun objelerini temizle
        enemies = [];
        stars = [];
        powerups = [];
        crystalDrops = [];
        particles = [];
        
        // Oyuncu konumunu ayarla
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.targetX = player.x; 
        player.targetY = player.y;
        
        // Arka plan ve oyuncu √ßiz
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        updateGameUI();
        drawPlayer(player);

        const countdownInterval = setInterval(() => {
            countdownValue--;
            
            if (countdownValue > 0) {
                document.getElementById('countdownDisplay').textContent = countdownValue;
            } else if (countdownValue === 0) {
                document.getElementById('countdownDisplay').textContent = 'GO!';
            } else {
                clearInterval(countdownInterval);
                document.getElementById('countdownDisplay').style.display = 'none';
                startGame();
            }
        }, 1000);
    }
    
    function startGame() {
        gameState = 'playing';
        gameRunning = true;
        score = 0;
        wave = 1;
        gameCrystals = 0;
        player.invincible = 0; 
        lastUpdateTime = performance.now(); 
        
        // Satƒ±n alƒ±nan boost'larƒ± uygula
        health = 3 + (BOOSTS.extraLife.purchased ? 1 : 0);
        hasShield = BOOSTS.startShield.purchased;
        activeBoosts = [];
        if (hasShield) activeBoosts.push({ name: 'Kalkan', icon: 'üõ°Ô∏è' });
        
        playerSpeedMultiplier = BOOSTS.speedBoost.purchased ? 1.2 : 1;
        if (BOOSTS.speedBoost.purchased) activeBoosts.push({ name: 'Hƒ±z', icon: '‚ö°' });
        
        // Oyuncuyu ortala
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.targetX = player.x; 
        player.targetY = player.y; 

        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('waveIndicator').style.display = 'block';
        document.getElementById('pauseBtn').style.display = 'flex';

        updateGameUI();
        spawnWave();
        
        gameLoop(performance.now());
    }

    function spawnWave() {
        stars = [];
        powerups = [];
        
        const starCount = WAVE_MANAGER.getStarCount(wave);
        for (let i = 0; i < starCount; i++) {
            stars.push(createStar());
        }

        enemies = [];
        const enemyCount = WAVE_MANAGER.getEnemyCount(wave);
        const isBossWave = WAVE_MANAGER.isBossWave(wave);
        
        if (isBossWave) {
            enemies.push(createEnemy('boss'));
        } else {
            for (let i = 0; i < enemyCount; i++) {
                enemies.push(createEnemy());
            }
        }

        if (Math.random() > 0.6) powerups.push(createPowerup('shield')); 
        if (Math.random() > 0.7 && health < 4) powerups.push(createPowerup('health')); 
        
        if (stars.length === 0 && enemies.length > 0) {
            setTimeout(checkWaveCompletion, 5000); 
        }
    }
    
    function checkWaveCompletion() {
        if (stars.length === 0 && enemies.length === 0) {
            wave++;
            gameCrystals += 5 + wave * 2;
            updateGameUI();
            spawnWave();
        } else if (gameState === 'playing') {
            setTimeout(checkWaveCompletion, 5000); 
        }
    }

    // Yardƒ±mcƒ± Varlƒ±k Olu≈üturucular
    function createStar() {
        return {
            x: Math.random() * (canvas.width - 100) + 50,
            y: Math.random() * (canvas.height - 100) + 50,
            radius: 15,
            collected: false,
            pulsePhase: Math.random() * Math.PI * 2
        };
    }

    function createEnemy(forceType = null) {
        const types = ['normal', 'fast', 'tank'];
        const weights = wave < 5 ? [1, 0, 0] : wave < 10 ? [0.7, 0.3, 0] : [0.5, 0.3, 0.2];
        const rand = Math.random();
        let type = forceType || 'normal';
        
        if (!forceType) {
            if (rand < weights[2]) type = 'tank';
            else if (rand < weights[1] + weights[2]) type = 'fast';
        }

        const baseSpeed = 2.5 * WAVE_MANAGER.getEnemySpeedMultiplier(wave);
        
        let enemy = {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 18,
            color: '#ff6b6b',
            baseSpeed: baseSpeed,
            speed: baseSpeed,
            angry: false,
            type: type,
            health: 1 
        };

        if (type === 'fast') {
            enemy.speed *= 1.5;
            enemy.radius = 14;
            enemy.color = '#ff9900';
        } else if (type === 'tank') {
            enemy.speed *= 0.6;
            enemy.radius = 24;
            enemy.color = '#8b0000';
            enemy.health = 3;
        } else if (type === 'boss') {
            enemy.speed *= 0.5;
            enemy.radius = 40;
            enemy.color = '#ff00ff';
            enemy.health = WAVE_MANAGER.getBossHealth(wave);
        }

        const side = Math.floor(Math.random() * 4);
        if (side === 0) enemy.x = -enemy.radius;
        else if (side === 1) enemy.x = canvas.width + enemy.radius;
        else if (side === 2) enemy.y = -enemy.radius;
        else enemy.y = canvas.height + enemy.radius;

        return enemy;
    }

    function createPowerup(type) {
        let color = '';
        let symbol = '';
        if (type === 'shield') { color = '#4ecdc4'; symbol = 'üõ°Ô∏è'; }
        else if (type === 'health') { color = '#ff6b6b'; symbol = '‚ù§Ô∏è'; }
        else if (type === 'slowdown') { color = '#9b59b6'; symbol = 'üïê'; }
        
        return {
            x: Math.random() * (canvas.width - 100) + 50,
            y: Math.random() * (canvas.height - 100) + 50,
            radius: 18,
            type: type,
            color: color,
            symbol: symbol,
            collected: false,
            rotation: 0
        };
    }

    function createParticles(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1,
                color,
                radius: Math.random() * 6 + 2
            });
        }
    }

    function dropCrystals(x, y, amount) {
        for (let i = 0; i < amount; i++) {
            crystalDrops.push({
                x: x + (Math.random() - 0.5) * 50,
                y: y + (Math.random() - 0.5) * 50,
                radius: 10,
                value: 1,
                collected: false,
                sparkle: 0
            });
        }
    }


    // B√ñL√úM E: √áARPƒ∞≈ûMA VE KAYIP MANTƒ∞ƒûI

    function checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        return Math.sqrt(dx * dx + dy * dy) < obj1.radius + obj2.radius;
    }

    function playerHit(enemy) {
        if (player.invincible > 0) return; 

        if (hasShield) {
            hasShield = false;
            activeBoosts = activeBoosts.filter(b => b.icon !== 'üõ°Ô∏è');
            updateGameUI();
            createParticles(player.x, player.y, '#64c8ff', 40);
            enemy.health = 0; 
            return;
        }

        health--;
        createParticles(player.x, player.y, '#ff6b6b', 50);
        updateGameUI();
        
        if (health <= 0) {
            gameOver();
        } else {
            player.invincible = 90; // 1.5 saniye
        }
    }
    
    function gameOver() {
        gameState = 'gameover';
        gameRunning = false;
        
        totalCrystalsEarned += gameCrystals;
        crystals += gameCrystals;
        if (wave > highestWave) highestWave = wave;
        
        setSafe('crystals', crystals);
        setSafe('totalCrystals', totalCrystalsEarned);

        // üîß D√úZELTME: totalPlayTime'ƒ± string deƒüil, direkt sayƒ± kaydediyoruz
        setSafe('totalPlayTime', totalPlayTime);

        setSafe('highestWave', highestWave);

        document.getElementById('ui').style.display = 'none';
        document.getElementById('waveIndicator').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'flex';
        
        document.getElementById('finalWave').textContent = wave;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('earnedCrystals').textContent = gameCrystals;
        document.getElementById('bestWave').textContent = highestWave;
        document.getElementById('reviveOffer').style.display = 'block'; 
        
        if (bgMusic) bgMusic.pause();
    }


    // B√ñL√úM F: √áƒ∞Zƒ∞M FONKSƒ∞YONLARI (KOZMETƒ∞KLER)

    function drawPlayerDefault(p) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
    }
    
    function drawPlayerStar(p) {
        const r = p.radius * 1.2;
        const spikes = 5;
        const outerRadius = r;
        const innerRadius = r / 2;
        
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        for (let i = 0; i < spikes; i++) {
            const angle = (Math.PI / spikes) * (2 * i - 0.5);
            ctx.lineTo(p.x + outerRadius * Math.cos(angle), p.y + outerRadius * Math.sin(angle));
            ctx.lineTo(p.x + innerRadius * Math.cos(angle + Math.PI / spikes), p.y + innerRadius * Math.sin(angle + Math.PI / spikes));
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ffae42';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function drawPlayerSquare(p) {
        const size = p.radius * 1.5;
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
        ctx.strokeStyle = '#cc0000';
        ctx.lineWidth = 3;
        ctx.strokeRect(p.x - size / 2, p.y - size / 2, size, size);
    }
    
    function drawPlayerTriangle(p) {
        const r = p.radius * 1.3;
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - r); 
        ctx.lineTo(p.x + r * Math.cos(Math.PI / 6), p.y + r * Math.sin(Math.PI / 6)); 
        ctx.lineTo(p.x + r * Math.cos(5 * Math.PI / 6), p.y + r * Math.sin(5 * Math.PI / 6)); 
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#27ae60';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function drawPlayerRing(p) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#4ecdc4';
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius * 0.8, 0, Math.PI * 2);
        ctx.strokeStyle = '#4ecdc4';
        ctx.lineWidth = p.radius * 0.4;
        ctx.stroke();
    }

    function drawPlayer(p) {
        if (SKINS[currentSkin]) {
            SKINS[currentSkin].draw(p);
        } else {
            drawPlayerDefault(p);
        }
        
        if (hasShield) {
            ctx.beginPath();
            const pulse = Math.sin(performance.now() / 100) * 5 + 25;
            ctx.arc(player.x, player.y, player.radius + pulse, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
            ctx.lineWidth = 5;
            ctx.stroke();
        }
    }
    

    // B√ñL√úM G: ANA OYUN D√ñNG√úS√ú

    function gameLoop(currentTime) {
        if (!gameRunning) return;
        requestAnimationFrame(gameLoop);
        
        const deltaTime = currentTime - lastUpdateTime;
        lastUpdateTime = currentTime;
        
        const expectedDelta = 1000 / 60;
        let timeStep = 1;
        if (deltaTime > 200) { 
            timeStep = 0; 
        } else if (deltaTime < 5) {
            timeStep = 0; 
        } else {
            timeStep = deltaTime / expectedDelta; 
        }
        
        updateGameUI();
        totalPlayTime += (deltaTime / 1000) * timeStep;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const currentSpeed = player.baseSpeed * playerSpeedMultiplier * timeStep;
        
        const dx = player.targetX - player.x;
        const dy = player.targetY - player.y;
        
        player.x += dx * 0.15 * timeStep;
        player.y += dy * 0.15 * timeStep;

        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        
        if (player.invincible > 0) player.invincible -= timeStep;
        
        ctx.save();
        if (player.invincible > 0 && Math.floor(player.invincible / 10) % 2 === 0) {
            ctx.globalAlpha = 0.5; 
        }
        
        drawPlayer(player);
        ctx.restore();


        enemies.forEach((enemy, index) => {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let enemyMoveSpeed = enemy.speed * timeStep;

            enemy.x += Math.cos(angle) * enemyMoveSpeed;
            enemy.y += Math.sin(angle) * enemyMoveSpeed;

            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            
            let scale = enemy.angry ? 1.2 + Math.sin(currentTime * 0.002) * 0.1 : 1;
            ctx.scale(scale, scale);

            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = (enemy.type === 'boss' ? '#ff00ff' : enemy.color);
            ctx.fill();

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (enemy.health > 1) {
                ctx.fillStyle = 'red';
                ctx.fillRect(-enemy.radius, enemy.radius + 5, enemy.radius * 2, 4);
                ctx.fillStyle = 'lime';
                const maxHealth = (enemy.type === 'boss' ? WAVE_MANAGER.getBossHealth(wave) : 3);
                ctx.fillRect(-enemy.radius, enemy.radius + 5, enemy.radius * 2 * (enemy.health / maxHealth), 4);
            }

            ctx.restore();

            if (player.invincible <= 0 && checkCollision(player, enemy)) {
                playerHit(enemy);
                if (enemy.type !== 'tank' && enemy.type !== 'boss') {
                    enemy.health = 0; 
                } else {
                    enemy.health -= 1;
                }
            }
        });
        
        stars.forEach((star, index) => {
            if (star.collected) return;

            const pulseRadius = star.radius + Math.sin(star.pulsePhase + currentTime * 0.005) * 2;
            ctx.beginPath();
            ctx.arc(star.x, star.y, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd700';
            ctx.fill();
            
            if (checkCollision(player, star)) {
                star.collected = true;
                score += 10;
                dropCrystals(star.x, star.y, 5); 
                createParticles(star.x, star.y, '#ffd700', 10);
                checkWaveCompletion(); 
            }
        });
        stars = stars.filter(s => !s.collected);

        powerups.forEach((pu, index) => {
            if (pu.collected) return;
            
            ctx.save();
            ctx.translate(pu.x, pu.y);
            ctx.rotate(pu.rotation);
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(pu.symbol, 0, 0);
            ctx.restore();
            
            pu.rotation += 0.01 * timeStep;
            
            if (checkCollision(player, pu)) {
                pu.collected = true;
                createParticles(pu.x, pu.y, pu.color, 20);
                activeBoosts = activeBoosts.filter(b => b.icon !== pu.symbol); 
                
                if (pu.type === 'shield') {
                    hasShield = true;
                    activeBoosts.push({ name: 'Kalkan', icon: 'üõ°Ô∏è' });
                } else if (pu.type === 'health' && health < (3 + (BOOSTS.extraLife.purchased ? 1 : 0))) {
                    health++;
                }
                updateGameUI();
            }
        });
        powerups = powerups.filter(pu => !pu.collected);


        crystalDrops.forEach((crystal, index) => {
            if (crystal.collected) return;
            
            if (BOOSTS.magnetBoost.purchased) {
                const dx = player.x - crystal.x;
                const dy = player.y - crystal.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 200) {
                    const angle = Math.atan2(dy, dx);
                    const pullSpeed = (200 - distance) / 50 * timeStep;
                    crystal.x += Math.cos(angle) * pullSpeed;
                    crystal.y += Math.sin(angle) * pullSpeed;
                }
            }

            ctx.beginPath();
            ctx.arc(crystal.x, crystal.y, crystal.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#4ecdc4';
            ctx.fill();
            
            if (checkCollision(player, crystal)) {
                crystal.collected = true;
                gameCrystals += crystal.value;
                createParticles(crystal.x, crystal.y, '#4ecdc4', 5);
            }
        });
        crystalDrops = crystalDrops.filter(c => !c.collected);

        particles.forEach((p, index) => {
            p.x += p.vx * timeStep;
            p.y += p.vy * timeStep;
            p.life -= 0.02 * timeStep;
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2);
            ctx.fill();
        });
        particles = particles.filter(p => p.life > 0);
        
        enemies.forEach(enemy => {
            if (enemy.health <= 0) {
                const dropAmount = (enemy.type === 'boss' ? 50 : (enemy.type === 'tank' ? 10 : 3));
                dropCrystals(enemy.x, enemy.y, dropAmount);
                createParticles(enemy.x, enemy.y, enemy.color, 30);
                score += dropAmount * 5; 
            }
        });
        enemies = enemies.filter(e => e.health > 0);
    }
    
    function pauseGame() {
        if (gameState !== 'playing') return;
        gameState = 'paused';
        gameRunning = false;
        document.getElementById('pauseScreen').style.display = 'flex';
        document.getElementById('pauseWave').textContent = wave;
        document.getElementById('pauseScore').textContent = score;
        document.getElementById('pauseCrystals').textContent = gameCrystals;
        if (bgMusic) bgMusic.pause();
    }

    function resumeGame() {
        gameState = 'playing';
        gameRunning = true;
        document.getElementById('pauseScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        lastUpdateTime = performance.now(); 
        if (bgMusic && isAudioOn) bgMusic.play();
        gameLoop(performance.now());
    }

    function restartFromPause() {
        document.getElementById('pauseScreen').style.display = 'none';
        prepareGame(); 
    }

    function quitToMenu() {
        gameState = 'menu';
        gameRunning = false;
        document.getElementById('pauseScreen').style.display = 'none';
        document.getElementById('ui').style.display = 'none';
        document.getElementById('waveIndicator').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        backToMenu();
    }

    function restartGame() {
        document.getElementById('gameOverScreen').style.display = 'none';
        prepareGame(); 
    }

    function backToMenu() {
        gameState = 'menu';
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('ui').style.display = 'none';
        document.getElementById('waveIndicator').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('startScreen').style.display = 'flex';
        updateMainMenuUI();
        if (bgMusic && isAudioOn) bgMusic.play().catch(()=>{});
    }

    // ƒ∞lk y√ºklemede ana men√ºy√º ayarla
    backToMenu();
    
</script>
